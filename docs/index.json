[{"content":"\u003cp\u003eThis is the beginning of a series of blog posts focusing on programming language identification in code files.\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis past summer, as part of work for the\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://codecommons.org/\"\u003eCodeCommons (CC)\u003c/a\u003e and\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.softwareheritage.org/\"\u003eSoftware Heritage (SWH)\u003c/a\u003e projects,\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI set out to run a series of tests benchmarking currently existing utilities that specialize in identifying programming languages (PL) in code files. In a series of blog posts, I will share my methods, results, and findings.\u003c/p\u003e\n\u003ch2 id=\"background\"\u003eBackground\u003c/h2\u003e\n\u003cp\u003eFirst, some background on the two projects involved.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSoftware Heritage\u003c/strong\u003e (SWH) is an effort to develop software to support open-source initiative that collects and preserves software in source code form [1]\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCodeCommons\u003c/strong\u003e (CC) is an effort to add historical data, metadata, and contextual links to Software Heritage (SWH) [2]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWithin the DiverSE team division of the CodeCommons project, one of the objectives, among several, has been to identify and categorize the syntax of code files hosted in the SWH archive.\u003c/p\u003e\n\u003ch2 id=\"motivation-and-objectives\"\u003eMotivation and Objectives\u003c/h2\u003e\n\u003ch3 id=\"broader-motivation\"\u003eBroader motivation\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eWhat are all PLs utilized in programming industry?\u003c/li\u003e\n\u003cli\u003eIs the SWH archive representative of all the (major) PLs in existence?\u003c/li\u003e\n\u003cli\u003eIs there a correlation between PL popularity (TIOBE) and SWH\u0026rsquo;s language frequency (COBOL model)? [3]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"technological-objective\"\u003eTechnological objective\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDetermine the PLs of a code source file [3]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"organizational-objective\"\u003eOrganizational objective\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDetermine the PL of every source file in the SWH archive; integrate the metadata into SWH\u0026rsquo;s data COBOL model [3]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"challenges\"\u003eChallenges\u003c/h2\u003e\n\u003ch3 id=\"accuracy\"\u003eAccuracy\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eConventional misidentification: C++ vs. Java\u003c/li\u003e\n\u003cli\u003eLanguage descendants and sub-families: C++ vs. C\u003c/li\u003e\n\u003cli\u003eVersion/dialect differentiation:\n\u003cul\u003e\n\u003cli\u003eFortran vs. Fortran77\u003c/li\u003e\n\u003cli\u003eRMarkdown vs. Markdown [3][4][5]\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"resource-usage\"\u003eResource-usage\u003c/h3\u003e\n\u003cp\u003efor the purposes of this blog post, as well as the subsequent ones in this series, resource-usage limitations are not in scope.\u003c/p\u003e\n\u003ch2 id=\"methods\"\u003eMethod(s)\u003c/h2\u003e\n\u003cp\u003eNow I will describe CC\u0026rsquo;s current approach to PL identification, including the\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003edataset,\u003c/li\u003e\n\u003cli\u003ePL identification techniques encountered, and\u003c/li\u003e\n\u003cli\u003eutilities currently explored.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"dataset\"\u003eDataset\u003c/h3\u003e\n\u003cp\u003eAt the time when I\u0026rsquo;d joined the CC, the team had been using \u003ca href=\"https://github.com/github-linguist/linguist/tree/main/samples\"\u003ethe dataset\u003c/a\u003e of the \u003ca href=\"https://github.com/github-linguist/linguist/tree/main\"\u003eLinguist\u003c/a\u003e PL identification tool. This has been out of convenience of having a dataset readily curated for testing PL identification [4]\u003c/p\u003e\n\u003cp\u003eLikewise, while the ultimate goal of the team is to classify data in the SWH archive, work on this specific objective began in the third part of 2025 and continues to be in progress, namely managing the protocol for traversing the SWH graph and the immense size of the data repository.\u003c/p\u003e\n\u003cp\u003eHere are some details on the Linguist dataset which the team has been using thus far, and with which I\u0026rsquo;ve continued experiments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e3039 programming files, and\u003c/li\u003e\n\u003cli\u003e680 syntaxes (i.e. PL) present [4][5][6]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhile the Linguist samples dataset has been a mainstay of our testing, it will certainly be valuable to evaluate this dataset in and of itself.\u003c/p\u003e\n\u003ch3 id=\"programming-language-identification-technique-types\"\u003eProgramming language identification technique types\u003c/h3\u003e\n\u003cp\u003eLet\u0026rsquo;s discuss some of the existing PL identification techniques types encountered on CC\u003c/p\u003e\n\u003ch3 id=\"classification-approaches\"\u003eClassification approaches\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHeuristics and Statistical classification\u003c/li\u003e\n\u003cli\u003eMachine Learning\u003c/li\u003e\n\u003cli\u003eLLM\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"data-delimitationprocessing-techniques\"\u003eData delimitation/processing techniques\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eFilename/extension\u003c/li\u003e\n\u003cli\u003eFile header: Shebang, vim/emacs modlines\u003c/li\u003e\n\u003cli\u003eCore file content analysis\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSome tools also use a combination of the approaches above to classify the file\u0026rsquo;s programmings language(s) in a sequential manner. Such an approach avoids more computationally expensive techniques (ex. processing core file contents) when a simpler approach (i.e. the filename/extension) suffices [4][5].\u003c/p\u003e\n\u003ch2 id=\"testing-method\"\u003eTesting method\u003c/h2\u003e\n\u003cp\u003eAs can be expected, the testing method which we employ on CC is straightforward\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eSelect the utility being tested\u003c/li\u003e\n\u003cli\u003eProvide each file from the file samples to the utility for classification\u003c/li\u003e\n\u003cli\u003eReceive the classification result and record it\u003c/li\u003e\n\u003cli\u003eRun an analysis of the utility classificaiton results juxtaposed against the ground truth to produce an accuracy to score.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThroughout updates, I will describe the testing procedure in more detail.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eWith this basis set, we\u0026rsquo;ll launch our exploration of PL identification in this series.\u003c/p\u003e\n\u003ch2 id=\"references\"\u003eReferences\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e[1] Software Heritage. [Online]. Available: \u003ca href=\"https://www.softwareheritage.org/\"\u003ehttps://www.softwareheritage.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e[2] Code·Commons. [Online]. Available: \u003ca href=\"https://codecommons.org/\"\u003ehttps://codecommons.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e[3] Software Heritage, “Programming Language Identification (PLI) for Software Heritage,” in \u003cem\u003eTechnical Committee Slides\u003c/em\u003e, 18 Jul. 2025. [Online]. Available: \u003ca href=\"https://gitlab.softwareheritage.org/teams/codecommons/cc-public-resources/-/blob/main/specifications/Programming%20Language%20Identification/slides_technical_committee_2025-05.pdf\"\u003ehttps://gitlab.softwareheritage.org/teams/codecommons/cc-public-resources/-/blob/main/specifications/Programming%20Language%20Identification/slides_technical_committee_2025-05.pdf\u003c/a\u003e. Version: Git commit 869b6b39.\u003c/p\u003e\n\u003cp\u003e[4] CodeCommons contributors. \u0026ldquo;2025-09-23 Syntax Identification on SWH,\u0026rdquo; CodeCommons GitLab repository, commit 227ccecb, 2025. [Online] Available: \u003ca href=\"https://gitlab.softwareheritage.org/teams/codecommons\"\u003ehttps://gitlab.softwareheritage.org/teams/codecommons\u003c/a\u003e (access restricted).\u003c/p\u003e\n\u003cp\u003e[5] Code Commons, “Syntax Identification for CodeCommons WP3.1,” in \u003cem\u003e2025 CodeCommons Annual Review Slides\u003c/em\u003e, 29 Sep. 2025. [Online]. Available: \u003ca href=\"https://gitlab.softwareheritage.org/teams/codecommons/cc-public-resources/-/blob/main/communication/2025-09-22_CC_Annual_Review/slides/Track1_Language-detection.pdf\"\u003ehttps://gitlab.softwareheritage.org/teams/codecommons/cc-public-resources/-/blob/main/communication/2025-09-22_CC_Annual_Review/slides/Track1_Language-detection.pdf\u003c/a\u003e. Version: Git commit 25f5129c.\u003c/p\u003e\n\u003cp\u003e[6] GitHub, Inc., “Linguist sample files dataset,” GitHub Linguist repository, commit a7e40d3, 2025. [Online]. Available: \u003ca href=\"https://github.com/github-linguist/linguist/tree/main/samples\"\u003ehttps://github.com/github-linguist/linguist/tree/main/samples\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n","description":"","image":null,"permalink":"https://jacobkohav.github.io/posts/2025-12-18-identifying-programming-languages/","title":"Identifying Programming Languages"},{"content":"\u003cp\u003eTesting the about page.\u003c/p\u003e\n","description":null,"image":null,"permalink":"https://jacobkohav.github.io/about/","title":"About"},{"content":"\u003cp\u003eTesting the about page.\u003c/p\u003e\n","description":null,"image":null,"permalink":"https://jacobkohav.github.io/contact/","title":"Contact"},{"content":"\u003ch1 id=\"content\"\u003eContent\u003c/h1\u003e\n\u003cp\u003eFolder for blogs, article, and tutorial posts\u003c/p\u003e\n","description":null,"image":null,"permalink":"https://jacobkohav.github.io/readme/","title":""}]